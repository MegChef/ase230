---
marp: true
---

# Q1. Understanding Request and Response

---

## Question 1.1

What does HTTP stand for, and what is its purpose in web communication?

**Answer:**
- HTTP stands for HyperText Transfer Protocol.

Its purpose in web communication is to define how data is formatted and transmitted between a client (usually a web browser) and a server (where the website or web service is hosted).

---

## Question 1.2

This is the basic HTTP cycle. Fill in ??#

```text
Client (Browser) ----[??1]----> Server
Client (Browser) <---[??2]---- Server
```

**Answer:**

??1 - HTTP Request
??2 - HTTP Response

---

## Question 1.3

These are the three main components of a raw HTTP request. What are ??#

- **Request Line**: Method + Path + HTTP Version
- **??1**: Metadata about the request
- **??2**: Data (for POST/PUT requests)

Example:

```http
POST /api HTTP/1.1
Host: localhost:8000
Content-Type: application/json

{
  "student_id": 1
}
```
---

**Answer:**

??1 - Headers
??2 - Body

---

## Question 1.4

Parsing incoming client requests is normally simple, and we can easily do it (T/F)?

**Answer:**
- False, because 
  - HTTP requests can vary in method, headers, and body format.
  - Different content types exist (application/json, multipart/form-data, text/html, etc.).
  - Clients may send malformed or incomplete requests.
  - Security concerns (e.g., injection attacks, oversized payloads, or invalid encodings) make parsing trickier.
---

## Question 1.5

This is the query parameter from the URL. Explain what each component means.

```txt
/search?name=John%20Doe&age=25&city=New%20York
```

Q1: What is the meaning of `/search`?
Q2: What is the meaning of the query string `name=John%20Doe&age=25&city=New%20York`?

---

**Answer:**
/search is the path of the URL.
- It tells the server which resource or endpoint is being requested.
- In this case, it probably maps to a "search" function or route on the server.
- The part after ? is the query string, which provides parameters to the server.
- It is made of key–value pairs separated by &.
- name=John%20Doe → The parameter name has the value John Doe (%20 = space).
- age=25 → The parameter age has the value 25.
- city=New%20York → The parameter city has the value New York.

So, the client is asking the server’s /search endpoint to look for a person named John Doe, aged 25, from New York.

---

## Question 1.6

Different formats require different parsing approaches:

- **JSON**: `{"name": "John"}`
- **Form data**: `name=John&age=25`
- **Multipart**: File uploads with boundaries
- **XML**: `<user><n>John</n></user>`

What challenges arise when parsing different content types manually?

---

**Answer:**
1. JSON (application/json)
- Must follow strict syntax (quotes, commas, braces).
- Errors in parsing (e.g., malformed JSON) can easily break manual parsers.
- Nested structures and arrays require recursive handling.

2. Form Data (application/x-www-form-urlencoded)
- Data is encoded in key=value&key2=value2 form.
- Special characters (spaces, &, =, +) require URL decoding.
- Handling missing values or repeated keys (e.g., color=red&color=blue).

---

3. Multipart Form Data (multipart/form-data)
- Used for file uploads or forms with mixed text + files.
- Boundaries (random strings that separate parts) must be detected correctly.
- Each part may have its own headers (like Content-Type, Content-Disposition).
- Handling binary data safely without corrupting files.

4. XML (application/xml or text/xml)
- Requires parsing hierarchical structures with tags.
- Must handle attributes, namespaces, and mixed content (text + elements).
- Vulnerable to XML External Entity (XXE) attacks if parsed incorrectly.

---

General Challenges Across All Types
- Encoding issues (UTF-8, ISO-8859-1, etc.).
- Error handling for malformed input.
- Security concerns: injections, oversized payloads (DoS), malicious content.
- Efficiency: Parsing large bodies (e.g., big JSON or XML) without exhausting memory.
---

## Question 1.7

A PHP Framework converts complex raw HTTP

```http
GET /api?name=John&age=25 HTTP/1.1
Host: localhost:8000
```

Into simple variable access through parsing:

```php
$method = $_SERVER['REQUEST_METHOD'];  // "GET"
$name = $_GET['name'];                 // "John"
$age = $_GET['age'];                   // "25"
```

PHP is the only framework that can do this (True or False).

**Answer:**
False. PHP is not the only framework that can parse raw HTTP into convenient variables. Almost every modern web framework provides this abstraction

---

## Summary

We have 7 questions on this page.

1. How many questions did you answer? (7 / 7)
2. What percentage of questions did you answer? (100%)
3. List question numbers that you cannot answer: N/A
4. (Optional) Explain why you could not answer these questions.
